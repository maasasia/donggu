package typescript

import (
	"fmt"
	"time"

	"github.com/maasasia/donggu/code"
	"github.com/maasasia/donggu/dictionary"
	"github.com/maasasia/donggu/util"
	"github.com/pkg/errors"
)

type ReactBuilderOptions struct {
	shortener util.Shortener
	metadata  *dictionary.Metadata
}

func (r *ReactBuilderOptions) SetShortener(shortener util.Shortener) {
	r.shortener = shortener
}

func (r *ReactBuilderOptions) SetMetadata(metadata *dictionary.Metadata) {
	r.metadata = metadata
}

func (r ReactBuilderOptions) ArgFormatter() ArgumentFormatter {
	return reactArgumentFormatter{metadata: r.metadata}
}

func (t ReactBuilderOptions) WriteHeader(builder *code.IndentedCodeBuilder) {
	builder.AppendLines(
		"// Generated with donggu at "+time.Now().UTC().Format(time.RFC3339),
		"// AUTOGENERATED CODE. DO NOT EDIT.",
		"",
		`import React from "react";`,
		"",
		`import { DictionaryFnItem, DictionaryNFnItem, EntryOptions } from "../types";`,
		`import { Formatter, replaceLineBreak as rlb } from "../util";`,
		`type ResolverFunc = (key: keyof typeof DATA, params: unknown, options?: EntryOptions, language?: Language) => string;`,
		"",
	)
}

func (t ReactBuilderOptions) WriteEntryType(builder *code.IndentedCodeBuilder, methodName, interfaceName string, entryKey dictionary.EntryKey) {
	if interfaceName == "" {
		builder.AppendLines(fmt.Sprintf("%s: DictionaryNFnItem;", methodName))
	} else {
		builder.AppendLines(fmt.Sprintf("%s: DictionaryFnItem<%s>;", methodName, interfaceName))
	}
}

func (t ReactBuilderOptions) WriteEntryImpl(builder *code.IndentedCodeBuilder, methodName, interfaceName string, entryKey dictionary.EntryKey) {
	if interfaceName == "" {
		builder.AppendLines(fmt.Sprintf(`%s(options?: EntryOptions) { return this.cb("%s", undefined, options) }`, methodName, t.shortener.Shorten(string(entryKey))))
	} else {
		builder.AppendLines(
			fmt.Sprintf(`%s(param: %s, options?: EntryOptions<%s>) { return this.cb("%s", param, options) }`,
				methodName, interfaceName, interfaceName, t.shortener.Shorten(string(entryKey))),
		)
	}
}

func (t ReactBuilderOptions) WriteEntryData(builder *code.IndentedCodeBuilder, argType, language, templateString string, entry dictionary.Entry) error {
	templateString = escapeTemplateStringLiteral(templateString)
	if argType == "" {
		builder.AppendLines(fmt.Sprintf("\"%s\": (options: EntryOptions) => <>{rlb(`%s`,options?.lineBreakElement)}</>,", language, templateString))
	} else {
		templateString, err := entry.ReplacedTemplateValue(language, func(key string, format dictionary.TemplateKeyFormat) (string, error) {
			call, callErr := t.ArgFormatter().Format(language, key, format)
			if callErr != nil {
				return "", errors.Wrapf(callErr, "failed to format template '%s'", key)
			}
			return "`,options?.lineBreakElement)}{" + call + "}{rlb(`", nil
		})
		if err != nil {
			return errors.Wrap(err, "failed to parse template parameter")
		}
		builder.AppendLines(fmt.Sprintf("\"%s\": (options: EntryOptions<%s>, param: %s) => <>{rlb(`%s`,options?.lineBreakElement)}</>,", language, argType, argType, templateString))
	}
	return nil
}
