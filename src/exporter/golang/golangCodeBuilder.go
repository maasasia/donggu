package golang

import (
	"fmt"
	"io"
	"time"

	"github.com/dave/jennifer/jen"
	"github.com/maasasia/donggu/dictionary"
	"github.com/pkg/errors"
)

type golangCodeBuilder struct {
	nodeTypeStmt   *jen.Statement
	nodeMethodStmt *jen.Statement
	dataMappings   map[string]map[string]*jen.Statement
	dataImplTypes  []jen.Code
	dataImplStmt   *jen.Statement
}

func newGolangCodeBuilder() *golangCodeBuilder {
	return &golangCodeBuilder{
		nodeTypeStmt:   jen.Empty(),
		nodeMethodStmt: jen.Empty(),
		dataMappings:   map[string]map[string]*jen.Statement{},
		dataImplTypes:  []jen.Code{},
		dataImplStmt:   jen.Empty(),
	}
}

func (g *golangCodeBuilder) outputNodeFile(w io.Writer, now time.Time) error {
	if err := g.writeHeader(w, now); err != nil {
		return err
	}
	file := jen.NewFile("generated")
	file.Add(jen.Line())
	file.Add(g.nodeTypeStmt)
	file.Add(g.nodeMethodStmt)
	if err := file.Render(w); err != nil {
		return errors.Wrap(err, "failed to render types.go")
	}
	return nil
}

func (g *golangCodeBuilder) outputDataFile(w io.Writer, now time.Time) error {
	if err := g.writeHeader(w, now); err != nil {
		return err
	}
	file := jen.NewFile("generated")

	formatterMappingDict := jen.Dict{}
	for key, entry := range g.dataMappings {
		entryJen := jen.Dict{}
		for lang, langValue := range entry {
			entryJen[jen.Lit(lang)] = langValue
		}
		formatterMappingDict[jen.Lit(key)] = jen.Values(entryJen)
	}

	formatterMappingValue := jen.Map(jen.String()).Map(jen.String()).Interface().Values(formatterMappingDict)
	file.Add(jen.Var().Id("formatterMappings").Op("="), formatterMappingValue)

	for _, line := range g.dataImplTypes {
		file.Add(line)
	}
	file.Add(jen.Line())
	file.Add(g.dataImplStmt)

	if err := file.Render(w); err != nil {
		return errors.Wrap(err, "failed to render data.go")
	}
	return nil
}

func (g *golangCodeBuilder) outputLanguageFile(w io.Writer, metadata dictionary.Metadata, now time.Time) error {
	if err := g.writeHeader(w, now); err != nil {
		return err
	}
	file := jen.NewFile("generated")

	languageSet := jen.Dict{}
	requiredLangs := metadata.RequiredLanguageSet()
	for _, language := range metadata.SupportedLanguages {
		if _, ok := requiredLangs[language]; ok {
			languageSet[jen.Lit(language)] = jen.Block(jen.True().Op(","))
		} else {
			languageSet[jen.Lit(language)] = jen.Block(jen.False().Op(","))
		}
	}
	file.Add(
		jen.Var().Id("languages").Op("="),
		jen.Map(jen.String()).Struct(jen.Bool()),
		jen.Values(languageSet),
	)

	for _, lang := range metadata.SupportedLanguages {
		file.Add(g.writePluralSelectorImpl(lang, &metadata))
	}

	if err := file.Render(w); err != nil {
		return errors.Wrap(err, "failed to render language.go")
	}

	return nil
}

func (g *golangCodeBuilder) writeHeader(w io.Writer, now time.Time) error {
	_, err := w.Write([]byte(
		fmt.Sprintf("// Generated with donggu at %s\n// AUTOGENERATED CODE. DO NOT EDIT.\n", now.UTC().Format(time.RFC3339)),
	))
	if err != nil {
		return errors.Wrap(err, "failed to write file")
	}
	return nil
}

func (g *golangCodeBuilder) writeNodeType(key dictionary.EntryKey) {
	structName := nodeStructName(key)
	g.nodeTypeStmt.Add(jen.Type().Id(structName).Struct(
		jen.Id("cb").Op("*").Id("Donggu"),
	), jen.Line())
}

func (g *golangCodeBuilder) writeNodeChild(key dictionary.EntryKey, child string, isRoot bool) {
	structName := nodeStructName(key)
	methodName := nodeMethodChildName(child)
	returnTypeName := nodeStructName(key.NewChild(child))

	var methodBody *jen.Statement
	var methodRecv *jen.Statement
	if isRoot {
		methodRecv = jen.Id("d").Id("*Donggu")
		methodBody = jen.Return(jen.Id(returnTypeName).Block(jen.Id("cb").Op(":").Id("d").Op(",")))
	} else {
		methodRecv = jen.Id("d").Id(structName)
		methodBody = jen.Return(jen.Id(returnTypeName).Call(jen.Id("d")))
	}

	method := jen.Func().Params(methodRecv).Id(methodName).Params().Id(returnTypeName).Block(methodBody)
	g.nodeMethodStmt.Add(method, jen.Line())
}

func (g *golangCodeBuilder) writeEntryMethod(key dictionary.EntryKey, paramArgs, callArgs []jen.Code) {
	structName := nodeStructName(key.Parent())
	methodName := nodeMethodChildName(key.LastPart())
	fnType := entryFormatTypeName(key)

	fnSignature := jen.Func().Params(jen.Id("d").Id(structName)).Id(methodName)
	fnSignature = fnSignature.Params(paramArgs...).String()

	fnCall := jen.List(jen.Id("fn"), jen.Id("ok")).Op(":=").
		Id("d").Dot("cb").Dot("resolve").Call(jen.Lit(string(key))).
		Assert(jen.Id(fnType))
	fnMissCheck := jen.If(jen.Op("!").Id("ok")).Block(
		jen.Panic(jen.Qual("errors", "New").Call(jen.Lit(fmt.Sprintf("cannot resolve function '%s'", key)))),
	)
	fnReturn := jen.Return(jen.Id("fn").Call(callArgs...))

	method := fnSignature.Block(fnCall, fnMissCheck, fnReturn)
	g.nodeMethodStmt.Add(method, jen.Line())
}

func (g *golangCodeBuilder) writeEntryType(key dictionary.EntryKey, paramArgs []jen.Code) {
	fnType := entryFormatTypeName(key)
	structCode := jen.Type().Id(fnType).Func().Params(paramArgs...).String()
	g.dataImplTypes = append(g.dataImplTypes, structCode)
}

func (g *golangCodeBuilder) writeEntryImpl(key dictionary.EntryKey, locale string, paramArgs []jen.Code, impl *jen.Statement) {
	fnName := entryFormatFnName(key, locale)
	fnType := entryFormatTypeName(key)
	if _, ok := g.dataMappings[string(key)]; !ok {
		g.dataMappings[string(key)] = map[string]*jen.Statement{}
	}
	g.dataMappings[string(key)][locale] = jen.Id(fnType).Call(jen.Id(fnName))

	fnDef := jen.Func().Id(fnName).Params(paramArgs...).String().Block(jen.Return(impl.Clone()))
	g.dataImplStmt.Add(fnDef, jen.Line())
}

func (g *golangCodeBuilder) writePluralSelectorImpl(language string, metadata *dictionary.Metadata) *jen.Statement {
	defs, defsOk := metadata.Plurals[language]
	if !defsOk {
		defs = dictionary.DefaultPluralDefinition()
	}
	fnName := pluralSelectorFnName(language)

	defCode := []jen.Code{}
	for index, def := range defs {
		if def.HasOperand {
			block := jen.If(jen.Id("value").Op(def.Op).Lit(def.Operand).Op("==").Lit(def.Equals)).Block(
				jen.Return(jen.Id("choices").Index(jen.Lit(index))),
			)
			defCode = append(defCode, block)
		} else {
			block := jen.If(jen.Id("value").Op(def.Op).Lit(def.Equals)).Block(
				jen.Return(jen.Id("choices").Index(jen.Lit(index))),
			)
			defCode = append(defCode, block)
		}
	}
	defCode = append(defCode, jen.Return(jen.Id("choices").Index(jen.Lit(len(defs)))))

	fnBody := jen.Func().Id(fnName).Params(jen.Id("value").Int(), jen.Id("choices").Index().String()).String().Block(defCode...)
	return fnBody
}
